import { ID_FIELD, WriteConfirmation } from "firestorm-db";
import {
	PackID,
	Texture,
	EntireUseToCreate,
	CreationPath,
	Path,
	Edition,
	EntireTextureToCreate,
	TextureCreationParam,
	TextureProperty,
	PropertyToOutput,
	FirestormTexture,
	TextureStats,
} from "../interfaces";
import TextureFirestormRepository from "../repository/texture.repository";
import PathService from "./path.service";
import UseService from "./use.service";

export default class TextureService {
	private readonly textureRepo = new TextureFirestormRepository();

	private readonly useService = new UseService();

	private readonly pathService = new PathService();

	static instance: TextureService;

	static getInstance() {
		if (!TextureService.instance) TextureService.instance = new TextureService();
		return TextureService.instance;
	}

	constructor() {
		TextureService.instance = this;
	}

	getRaw(): Promise<Record<string, Texture>> {
		return this.textureRepo.getRaw();
	}

	getById(id: string | number) {
		return this.textureRepo.getById(id);
	}

	getByNameOrId(nameOrID: string | number): Promise<FirestormTexture | FirestormTexture[]> {
		return this.textureRepo.search(nameOrID);
	}

	async getPropertyById<Property extends TextureProperty>(
		id: number,
		property: Property,
	): Promise<PropertyToOutput<Property>> {
		// even though it uses the name endpoint it's still pretty fast
		// since it returns early if it finds an numeric id
		return this.textureRepo.searchProperty(id, property);
	}

	// used on webapp texture page + gallery
	async search(
		search: string | undefined,
		tag: string | undefined,
		partial = false,
	): Promise<Texture[]> {
		const results = await this.textureRepo.search(search, tag, partial);
		return Array.isArray(results) ? results : [results];
	}

	async searchProperty<Property extends TextureProperty>(
		nameOrID: string | number,
		property: Property,
	): Promise<PropertyToOutput<Property>> {
		try {
			return await this.textureRepo.searchProperty<Property>(nameOrID, property);
		} catch {
			throw new Error(`Failed to search property "${property}" on texture ${nameOrID}`);
		}
	}

	async getStats(): Promise<TextureStats> {
		const raw = await this.getRaw();
		const data = Object.values(raw);
		const { byEditions, byTags } = data
			.flatMap((texture) => texture.tags)
			.reduce(
				(acc, cur) => {
					if (["Java", "Bedrock"].includes(cur)) {
						acc.byEditions[cur] ||= 0;
						++acc.byEditions[cur];
					} else {
						acc.byTags[cur] ||= 0;
						++acc.byTags[cur];
					}
					return acc;
				},
				{ byEditions: {}, byTags: {} },
			);
		return {
			total_textures: data.length,
			textures_by_edition: byEditions,
			textures_by_tags: byTags,
		};
	}

	getURLById(id: number, pack: PackID, version: string): Promise<string> {
		return this.textureRepo.getURLById(id, pack, version);
	}

	getEditions(): Promise<string[]> {
		return this.textureRepo.getEditions();
	}

	getResolutions(): Promise<number[]> {
		return this.textureRepo.getResolutions();
	}

	getAnimated(): Promise<number[]> {
		return this.textureRepo.getAnimated();
	}

	getTags(): Promise<string[]> {
		return this.textureRepo.getTags();
	}

	getVersions(): Promise<string[]> {
		return this.textureRepo.getVersions();
	}

	getVersionByEdition(edition: Edition): Promise<string[]> {
		return this.textureRepo.getVersionByEdition(edition);
	}

	async mergeTextures(source: string, destination: string) {
		// append the uses of the source texture to the uses of the destination texture
		const { uses: usesToRemove, paths: pathsToRemove } = await this.searchProperty(source, "all");

		// no need to delete use properties because it gets overwritten later anyways
		const usesToCreate: EntireUseToCreate[] = usesToRemove.map((use) => ({
			...use,
			paths: pathsToRemove
				.filter((p) => p.use === use[ID_FIELD])
				// typescript shenanigans to delete properties
				.map((path: CreationPath & Partial<Path>) => {
					delete path[ID_FIELD];
					delete path.use;
					return path;
				}),
		}));

		await Promise.all([
			this.useService.appendMultipleUses(destination, usesToCreate),
			this.deleteTexture(source),
		]);
	}

	createTexture(texture: TextureCreationParam): Promise<Texture> {
		return this.textureRepo.createTexture(texture);
	}

	async createEntireTextures(body: EntireTextureToCreate[]): Promise<Texture[]> {
		// must do this before anything else to prevent id collisions
		const createdTextures = await this.textureRepo.createTexturesBulk(
			body.map((tex) => ({ name: tex.name, tags: tex.tags })),
		);

		// can be done in parallel because all autogenerated ids at this point are known
		const useResults = await Promise.all(
			// addBulk maintains key order so we can use the index reliably here
			body.map((tex, i) =>
				this.useService.generateAppendableUses(createdTextures[i][ID_FIELD], tex.uses, true),
			),
		);

		// flatMap to save requests (ids are known so we only need one request to add everything)
		await Promise.all([
			this.useService.createMultipleUses(useResults.flatMap((r) => r.usesToCreate)),
			this.pathService.createMultiplePaths(useResults.flatMap((r) => r.pathsToCreate)),
		]);

		return createdTextures;
	}

	async editTexture(id: string, body: TextureCreationParam): Promise<Texture> {
		await this.getByNameOrId(id);
		return this.textureRepo.editTexture(id, body);
	}

	deleteTexture(id: string): Promise<WriteConfirmation[]> {
		return this.textureRepo.deleteTexture(id);
	}
}
